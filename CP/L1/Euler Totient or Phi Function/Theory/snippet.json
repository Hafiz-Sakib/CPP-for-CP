"ModularArithmetic": {
    "prefix": "ModularArithmetic",
    "body": [
      "void normal(ll &a)",
      "{",
      "    a %= mod;",
      "    (a < 0) && (a += mod);",
      "}",
      "ll modMul(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a * b) % mod;",
      "}",
      "ll modAdd(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a + b) % mod;",
      "}",
      "ll modSub(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    a -= b;",
      "    normal(a);",
      "    return a;",
      "}",
      "ll modPow(ll b, ll p)",
      "{",
      "    ll r = 1;",
      "    while (p)",
      "    {",
      "        if (p & 1)",
      "        {",
      "            r = modMul(r, b);",
      "        }",
      "        b = modMul(b, b);",
      "        p >>= 1;",
      "    }",
      "    return r;",
      "}",
      "ll modInverse(ll a)",
      "{",
      "    return modPow(a, mod - 2);",
      "}",
      "ll modDiv(ll a, ll b)",
      "{",
      "    return modMul(a, modInverse(b));",
      "}"
    ],
    "description": "ModularArithmetic"
  },
  "EulerPhiFunction": {
    "prefix": "EulerPhiFunction",
    "body": [
      "int EulerPhi(int n)",
      "{",
      "    int ans = n;",
      "    for (auto p : primes)",
      "    {",
      "        if (p * 1LL * p > n)",
      "        {",
      "            break;",
      "        }",
      "        if (n % p == 0)",
      "        {",
      "            ans /= p;",
      "            ans *= (p - 1);",
      "            while (n % p == 0)",
      "            {",
      "                n /= p;",
      "            }",
      "        }",
      "    }",
      "",
      "    if (n > 1)",
      "    {",
      "        ans /= n;",
      "        ans *= (n - 1);",
      "    }",
      "",
      "    return ans;",
      "}"
    ],
    "description": "EulerPhiFunction"
  },